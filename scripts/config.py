#!/usr/bin/python3

# generates configuration header from the config file
# you can check out the default configuration in config/default.json

# also don't run this script directly, use the make command instead

from typing import IO, Any, List, Dict
from datetime import datetime
from sys import argv
import string
import json

# allowed chars for the option name
option_allowed = list(string.ascii_letters + string.digits + "_")

# chars to replace in the option name
option_replace_list = [(" ", "_"), ("-", "_"), ("/", "_")]


# represents a single option in the configuration
class option:
    def __init__(self, name: str, opt: dict) -> None:
        self.name = name

        if "value" not in opt.keys():
            raise Exception(
                'option "%s" does not have the required key: "value"' % self.name
            )

        if "type" not in opt.keys():
            raise Exception(
                'option "%s" does not have the required key: "type"' % self.name
            )

        self.desc = opt["desc"]
        self.type = opt["type"]

        self.value_bool: bool = False
        self.value_int: int = 0
        self.value_str: str = ""

        if self.type == "boolean" and isinstance(opt["value"], bool):
            self.value_bool = opt["value"]

        elif self.type == "integer" and isinstance(opt["value"], int):
            self.value_int = opt["value"]

        elif self.type == "string" and isinstance(opt["value"], str):
            self.value_str = opt["value"]

        else:
            raise Exception(
                'option "%s" has an invalid type, use boolean, integer or string'
                % self.name
            )

    # returns the header file macro name from the option name
    def _macro_name(self) -> str:
        macro = self.name.upper()

        # replace all the mapped chars
        for r in option_replace_list:
            macro = macro.replace(r[0], r[1])

        # remove the chars that are not allowed
        for c in macro:
            if c in option_allowed:
                continue
            macro = macro.replace(c, "")

        return macro

    # returns the header file macro value from the option value
    def _macro_value(self) -> str:
        if self.type == "boolean":
            return "1" if self.value_bool else "0"

        elif self.type == "integer":
            return str(self.value_int)

        elif self.type == "string":
            return self.value_str

        return "0"

    # retuns the macro from the name and the value
    def macro(self) -> str:
        res = f"// {self.desc}\n"
        res += f"#define CONFIG_{self._macro_name()} ({self._macro_value()})\n"
        return res


# represents and stroes the configuration
class config:
    def __init__(self, src: str, dst: str) -> None:
        self.src: str = src
        self.dst: str = dst

        # list of file descs opened with _open
        self.fds: List[IO[Any]] = []

        # a list of all the configuration options
        self.options: List[option] = []

    def _open(self, path: str, write: bool) -> IO[Any]:
        try:
            fd = open(path, "w" if write else "r")
            self.fds.append(fd)
        except Exception as e:
            raise Exception("failed to open file (%s): %s" % (path, e))
        return fd

    def _load_option(self, prefix: str, val: List[Dict[str, dict]]) -> None:
        for v in val:
            name = list(v.keys())[0]
            conf = v[name]

            try:
                opt = option(f"{prefix}_{name}" if prefix != "" else name, conf)
                self.options.append(opt)
            except Exception as e:
                raise e

    def clean(self) -> None:
        for fd in self.fds:
            fd.close()
        self.fds.clear()

    def parse(self) -> bool:
        # open the source and load the JSON
        src = self._open(self.src, False)
        config = json.load(src)

        for k in config.keys():
            if isinstance(config[k], list):
                self._load_option(k, config[k])
            elif isinstance(config[k], dict):
                self._load_option("", [{k: config[k]}])
            else:
                raise Exception("invalid config option: %s" % k)

        header = "#pragma once\n\n"
        header += "/*\n"
        header += "\n"
        header += " * this header is generated by the configuration script, see scripts/config.py\n\n"
        header += " * to edit the configuration, edit the .config file (can be generated by make config)\n"
        header += " * and run the make command again to regenerate this file\n\n"
        header += "*/\n\n"

        # open and write generated configs to the destination file
        dst = self._open(self.dst, True)
        dst.write(header)

        for o in self.options:
            dst.write(o.macro() + "\n")

        # clean up resources
        conf.clean()
        return True


class logger:
    def _get_time(self) -> str:
        return datetime.now().strftime("%H:%M:%S")

    def _log(self, color: str, tag: str, text: str) -> None:
        # print(f"\x1b[1m{self._get_time()} {color}{tag}\x1b[0m {text}")
        print(f"\x1b[1m{color}{tag}\x1b[0m {text}")

    def info(self, text: str) -> None:
        self._log("\x1b[34m", "INFO", text)

    def warn(self, text: str) -> None:
        self._log("\x1b[33m", "WARN", text)

    def fail(self, text: str) -> None:
        self._log("\x1b[31m", "FAIL", text)


if __name__ == "__main__":
    # used for simple logging
    log = logger()

    if len(argv) != 3:
        log.fail("please provide the required arguments")
        log.info("usage: %s [input file] [output file]" % argv[0])
        exit(1)

    # create the configuration
    conf = config(argv[1], argv[2])

    # try to parse it
    try:
        if not conf.parse():
            log.fail("failed to parse the configuration")
            exit(1)
    except Exception as e:
        conf.clean()
        log.fail(e.__str__())
        exit(1)

    log.info("parsed configuration has been saved to %s" % argv[2])
